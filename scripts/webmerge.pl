#!/usr/bin/perl
################################################################################
# Copyright 2013 by Marcel Greter
# This file is part of Webmerge (GPL3)
################################################################################

use Carp;
use strict;
use warnings;

################################################################################

# use FindBin to find the path to the script
# from here the config file for be relative
# this is not true if config path is absolute
use FindBin qw($Bin);

# insert our module directory to lib search directory
# we want to keep our modules local and not install global
BEGIN { unshift @INC, "$Bin/modules"; }

################################################################################

# get working directory
use Cwd qw(getcwd abs_path);

# load spriteset library
use OCBNET::Spritesets;

# load local modules
use RTP::Webmerge;
use RTP::Webmerge::IO;
use RTP::Webmerge::Path;
use RTP::Webmerge::Merge;
use RTP::Webmerge::Prepare;
use RTP::Webmerge::HeadInc;
use RTP::Webmerge::Embeder;
use RTP::Webmerge::Optimize;
use RTP::Webmerge::Checksum;
use RTP::Webmerge::Watchdog;

# load additional modules (no import)
use RTP::Webmerge::Compile::JS qw();
use RTP::Webmerge::Compile::CSS qw();
use RTP::Webmerge::Process::JS qw();
use RTP::Webmerge::Process::CSS qw();

# load optimizer modules (no import)
use RTP::Webmerge::Optimize::TXT qw();
use RTP::Webmerge::Optimize::GIF qw();
use RTP::Webmerge::Optimize::JPG qw();
use RTP::Webmerge::Optimize::PNG qw();
use RTP::Webmerge::Optimize::MNG qw();
use RTP::Webmerge::Optimize::ZIP qw();
use RTP::Webmerge::Optimize::GZ qw();

################################################################################
# get the mother pid
################################################################################

my $pid = $$;

################################################################################
# get current working directory
################################################################################

my $cwd = abs_path(getcwd);

################################################################################
# declare and init configuration options
################################################################################

my $config =
{

	# where is you htdocs root directory
	# this is needed to create absolute urls
	# default is relative to the config file
	'webroot' => '{CONF}/..',

	# define a current working directory
	# you can adjust this also in the xml config
	# it's also possible to change it only for a block
	'directory' => '{WWW}',

	# default configuration file relative from our webroot
	# this is the main source for all other configuration options
	'configfile' => '{EXT}/conf/webmerge.conf.xml',

	# header to prepend to all generated merge output files
	'headtmpl' => "/* autogenerated by webmerge (%s context) */\n",

	# doctype to render includes
	'doctype' => 'html5',

	# debug mode
	'debug' => 0,

	# preapre stuff
	'prepare' => 0,
	# optimize stuff
	'optimize' => 0,
	# merge configured stuff
	'merge' => 0,
	# create head includes
	'headinc' => 0,
	# create embeder
	'embeder' => 0,
	# start watchdog
	'watchdog' => 0,

	# license stuff
	'license' => 1,
	# compile stuff
	'compile' => 1,
	# minify stuff
	'minify' => 1,
	# join stuff
	'join' => 1,
	# dev stuff
	'dev' => 1,

	# do end crc-check
	'crc-check' => 0,

	# various crc features
	'crc-file' => 1,
	'crc-comment' => 1,

	# referer for downloads
	'referer' => undef,

	# parallel jobs
	'jobs' => 2,

	# the order in which to prefer to include stuff
	'incorder' =>
	{
		'dev' => ['dev', 'join', 'minify', 'compile'],
		'live' => ['compile', 'minify', 'join', 'dev']
	}

};
# EO config

################################################################################
# get config options from the command line
################################################################################

# load commandline option fetcher
use Getopt::Long qw(GetOptions);

# load help message generator
use Pod::Usage qw(pod2usage);

# command line only options
# cannot be overriden by config
my ($man, $help, $opts) = (0, 0, 0);

# create the options array
my @opts = (

	# the main config file (only from cmd line)
	'configfile|f=s' => \$config->{'configfile'},

	# enable/disable debug mode
	'debug|dbg!' => \$config->{'cmd_debug'},

	# maybe change these in the config file
	'webroot=s' => \$config->{'cmd_webroot'},
	'doctype|d=s' => \$config->{'cmd_doctype'},

	# enable/disable base operations
	'prepare|p!' => \$config->{'cmd_prepare'},
	'optimize|o!' => \$config->{'cmd_optimize'},
	'merge|m!' => \$config->{'cmd_merge'},
	'headinc|i!' => \$config->{'cmd_headinc'},
	'embeder|e!' => \$config->{'cmd_embeder'},
	'watchdog|w!' => \$config->{'cmd_watchdog'},
	'crc-check|c!' => \$config->{'cmd_crc-check'},

	# various crc features
	'crc-file!' => \$config->{'cmd_crc-file'},
	'crc-comment!' => \$config->{'cmd_crc-comment'},

	# enable/disable stage operations
	'license!' => \$config->{'cmd_license'},
	'compile!' => \$config->{'cmd_compile'},
	'minify!' => \$config->{'cmd_minify'},
	'join!' => \$config->{'cmd_join'},
	'dev!' => \$config->{'cmd_dev'},

	# referer http header for downloads
	'referer|r=s' => \$config->{'cmd_referer'},

	# header tempalte to prepend to files
	'headtmpl|h=s' => \$config->{'cmd_headtmpl'},

	# number of commands to run simultaneously
	'jobs|j=i' => \$config->{'cmd_jobs'},

	# usage/help options
	'help|?' => \$help,
	'opts' => \$opts,
	'man' => \$man,

	# init config will prepare additional configuration
	# returns additional options to be fetched from cmd
	initConfig($config)

);
# EO @options

# get options from commandline
GetOptions(@opts) or pod2usage(2);

################################################################################

# uncomment if you want to see all options
if ($opts)
{
	print join("\n", map {
		s/(?:\!|\=.*?)$//;
		join(', ', map { '-' . $_ } split /\|/);
	} sort keys %{ { @opts } });
}

################################################################################

# show help page
pod2usage(1) if $help;

# show man page if requested by command line
pod2usage(-exitval => 0, -verbose => 2) if $man;

################################################################################
# read the configuration file
################################################################################

# load xml module
use XML::Simple;

# search for the config file
my $configfile = 'webmerge.conf.xml';

# register extension path within our path modules for later use
$RTP::Webmerge::Path::extroot = check_path(join('/', $Bin, '..'));

# helper sub to check file for existence
sub checkFile { defined $_[0] && -e $_[0] ? $_[0] : undef; }

# check if configfile is given as relative path
unless ( $config->{'configfile'} =~ m/^\// )
{
	# search for the config file
	$config->{'configfile'} =
		# first try from current directory
		checkFile(check_path($config->{'configfile'}));
}

# abort if the configuration file was not found
die "configfile not found" unless $config->{'configfile'};

# create the config path from config file ...
$config->{'configpath'} = $config->{'configfile'};
# ... and remove the trailing filename
$config->{'configpath'} =~ s/\/[^\/]+$//;

# register path within our path modules for later use
$RTP::Webmerge::Path::confroot = $config->{'configpath'};


################################################################################
# xml helper function for the include directive
################################################################################

# returns xml fragment as string
# read the given file and do includes
sub get_xml
{

	# get the filenname
	my ($file, @config) = @_;

	# resolve the file path
	$file = check_path($file);

	# read the complete xml file
	my $data = readfile($file) || return;

	# replace include tags with the real content of the file to be included
	${$data} =~ s/<include\s+src=(?:\'([^\']+)\'|\"([^\"]+)\"|(\w+))\s*\/?>/get_xml($1||$2||$3)/egm;

	# parse and create the xml document
	my $xml = XMLin(${$data}, 'ForceArray' => 1, 'KeyAttr' => []);

	# return the xml fragment
	return XMLout($xml, 'KeyAttr' => [], 'RootName' => undef);

}
# EO get_xml


# returns xml document as object
# read the given file and do includes
sub read_xml
{

	# get the filenname
	my ($file, @config) = @_;

	# resolve the file path
	$file = check_path($file);

	# read the complete xml file
	my $data = readfile($file) || return;

	# die if config file is empty
	die "empty config file <$file>" if ${$data} eq "";

	# replace include tags with the real content of the file to be included
	${$data} =~ s/<include\s+src=(?:\'([^\']+)\'|\"([^\"]+)\"|(\w+))\s*\/?>/get_xml($1||$2||$3)/egm;

	# parse and create the xml document
	my $xml = XMLin(${$data}, 'ForceArray' => 1, 'KeyAttr' => []);

	# return XML doc
	return $xml;

}
# EO read_xml


################################################################################
# read and parse the xml configuration
################################################################################

# parse the xml configuration file
my $xml = read_xml($config->{'configfile'})
	or die 'error while reading config file, aborting';


################################################################################
# apply the configuration from the xml to the config hash
################################################################################

# process all config nodes in config file
foreach my $cfg (@{$xml->{'config'} || []})
{

	# process all given configuration keys
	foreach my $key (keys %{$cfg || {}})
	{

		# do not create unknown config keys
		next unless exists $config->{$key};

		# assign the value from the first item
		$config->{$key} = $cfg->{$key}->[0];

		# if we got a hash we had an empty tag
		if (ref($config->{$key}) eq 'HASH')
		{ $config->{$key} = ''; }

	}
	# EO each xml config key

}
# EO each xml config

# store xml reference
$config->{'xml'} = $xml;


################################################################################
# apply overruling command line options after xml has been applied
################################################################################

# search all config keys for /^cmd_/
# options from command line overrule
# all other configuration options
foreach my $key (keys %{$config})
{

	# only process cmd keys
	next unless $key =~ s/^cmd_//;

	# only process valid cmd keys
	next unless defined $config->{'cmd_'.$key};

	# overrule the option from cmd line
	$config->{$key} = $config->{'cmd_'.$key};

	# remove cmd option from config
	delete $config->{'cmd_'.$key};

}
# EO each config key

################################################################################
# setup some paths to be used by all other functions
################################################################################

# set htdocs root directory and current working directory
$RTP::Webmerge::Path::webroot = check_path($config->{'webroot'} || '.');
$RTP::Webmerge::Path::directory = check_path($config->{'directory'} || '.');

################################################################################

# only allow directory or query option to be given for fingerprinting
if ($config->{'fingerprint-dev'} && !($config->{'fingerprint-dev'} =~ m/^[qfn]/i))
{ die "invalid fingerprinting set for dev: <" .  $config->{'fingerprint-dev'} . ">"; }
if ($config->{'fingerprint-live'} && !($config->{'fingerprint-live'} =~ m/^[qfn]/i))
{ die "invalid fingerprinting set for live: <" .  $config->{'fingerprint-live'} . ">"; }

# normalize fingerprint configuration to the first letter (lowercase)
$config->{'fingerprint-dev'} = lc substr($config->{'fingerprint-dev'}, 0, 1);
$config->{'fingerprint-live'} = lc substr($config->{'fingerprint-live'}, 0, 1);
# disable the fingerprint option if the given value is no or none
$config->{'fingerprint-dev'} = undef if $config->{'fingerprint-dev'} eq 'n';
$config->{'fingerprint-live'} = undef if $config->{'fingerprint-live'} eq 'n';


################################################################################
# setup configuration for external downloads
# so far this can only be set by the config file
################################################################################

# init the config array
$config->{'external'} = [];

# process all config nodes in config file
foreach my $cfg (@{$xml->{'config'} || []})
{

	# process all given external options
	foreach my $ext (@{$cfg->{'external'} || []})
	{

		# get content from xml node
		my $enabled = $ext->{'content'};
		# enable when tag was self closing
		$enabled = 1 unless defined $enabled;
		# push hash object to config array
		unshift @{$config->{'external'}},
		{
			'enabled' => $enabled,
			'href' => $ext->{'href'},
			'referer' => $ext->{'referer'},
		};

	}
	# EO each external

}
# EO each xml config


################################################################################
# declare status variables and attach to config hash
################################################################################

# store atomic operations
$config->{'atomic'} = {};

# store temporarily files
$config->{'temps'} = [];


################################################################################
# setup teardown handlers before main program
################################################################################

# exit on ctrl+c, this make sure
# that the end handler is called
local $SIG{'INT'} = sub { exit; };

# this will always be called
# when the main script exists
END
{
	# only mother takes care of this
	if ($pid == $$)
	{
		# delete all temporarily created files
		foreach (@{$config->{'temps'} || []}) { unlink $_ if -e $_; }
		# delete all atomic temporarily files (struct: [data, blessed])
		foreach (values %{$config->{'atomic'} || {}}) { $_->[1]->delete; }
	}
	# EO if mother
}


################################################################################
# check the configuration before goind to execute main program
################################################################################

# check config will assert the configuration
# call after you have read command line options
checkConfig($config) or die "config check failed";


################################################################################
# remove xml for not mentioned steps
################################################################################

# if some arguments are given we only want to merge given steps
# therefore remove all other steps from the configuration file
if (scalar(@ARGV))
{

	# create regular expression to match steps
	my $re_argv = join('|', @ARGV);

	# loop all operation nodes (which could have an step)
	foreach my $node
	(
		@{$xml->{'merge'} || []},
		@{$xml->{'prepare'} || []},
		@{$xml->{'headinc'} || []},
		@{$xml->{'embeder'} || []},
		@{$xml->{'optimize'} || []},
	)
	{

		# get all subnodes from the main operation nodes
		my @subnodes = grep { ref($_) eq 'ARRAY' } values %{$node};

		# should we keep the root node
		# otheriwse it may be disabled
		my $keep_root = 0;

		# keep all subnodes if the root node should be generated
		my $keep_sub = $node->{'step'} && $node->{'step'} =~ m/^(?:$re_argv)$/;

		# process each subnode
		foreach my $subnode (map { @{$_} } @subnodes)
		{

			# abort loop if we want to keep all subnodes
			# othwerwise it may be disabled if step doesn't match
			next if $keep_sub || ref($subnode) ne 'HASH';

			# only can remove items with step
			next unless $subnode->{'step'};

			# test if we should disable this node from the xml
			unless ($subnode->{'step'} =~ m/^(?:$re_argv)$/)
			{

				# simply disable this subnode
				$subnode->{'disabled'} = 'true';

			}
			else
			{

				# keep this root node
				$keep_root = 1;

			}
			# EO if step matches argv

		}
		# EO each subnode

		# abort loop if we want to keep the root node
		# othwerwise it may be disabled if step doesn't match
		next if $keep_root;

		# only can remove items with step
		next unless $node->{'step'};

		# test if we should disable this node from the xml
		unless ($node->{'step'} =~ m/^(?:$re_argv)$/)
		{

			# simply disable this node
			$node->{'disabled'} = 'true';

		}
		# EO if disable node

	}
	# EO foreach nodes

}
# EO input arguments


################################################################################
# remove xml for dublicate ids (only use last)
################################################################################

# get nodes arrays to clean
foreach my $nodes
(
	($xml->{'prepare'} || []),
	($xml->{'headinc'} || []),
	($xml->{'feature'} || []),
	($xml->{'embeder'} || []),
	($xml->{'optimize'} || []),
	(map { $_->{'js'} || [] } @{$xml->{'merge'} || []}),
	(map { $_->{'css'} || [] } @{$xml->{'merge'} || []})
)
{

	# count block occurences
	# blocks identified by id
	my %known_id;

	# loop from behind so we can splice items out
	for (my $i = $#{$nodes}; $i != -1; -- $i)
	{

		# the the id of this block (skip if undefined)
		my $id = $nodes->[$i]->{'id'} || next;

		# increment id counter
		# will init automatically
		$known_id{$id} += 1;

		# always keep the first node
		# the loop is going from behind
		# so this is actually the last node
		next if ($known_id{$id} == 1);

		# splice out all other nodes with
		# the same type and identifier
		splice(@{$nodes}, $i, 1);

	}

}
# EO loop arrays to clean


################################################################################
# main execution of the operations
################################################################################

unless ($config->{'watchdog'})
{

	# call the action step first
	# this will create directories
	if ($config->{'prepare'} && $xml->{'prepare'})
	{ prepare($config, $_) foreach @{$xml->{'prepare'}}; }

	# call the optimization step next
	# this will change some source files
	if ($config->{'optimize'} && $xml->{'optimize'})
	{ optimize($config, $_) foreach @{$xml->{'optimize'}}; }

	# next we will continue with the merge step
	# this will write generated and processed files
	if ($config->{'merge'} && $xml->{'merge'})
	{ merge($config, $_) foreach @{$xml->{'merge'}}; }

	# call headinc function to generate headers
	# these can be included as standalone files
	# they have includes for all the css and js files
	if ($config->{'headinc'} && $xml->{'headinc'})
	{ headinc($config, $_) foreach @{$xml->{'headinc'}}; }

	# call embeder to create standalone embeder code
	# this code will sniff the environment to choose
	# the correct headinc to be included in the html
	if ($config->{'embeder'} && $xml->{'embeder'})
	{ embeder($config, $_) foreach @{$xml->{'embeder'}}; }

}

################################################################################
# now commit all changes
################################################################################

# reset atomic operations
# this will commit all changes
$config->{'atomic'} = {};

# delete all temporarily created files
foreach (@{$config->{'temps'} || []})
{ unlink $_ if -e $_; }

# reset temporarily files
$config->{'temps'} = [];

################################################################################
# start the watchdog at the end to monitor changes
################################################################################

# call watchdog to watch for file changes
# will call merge directly if something changes
# also takes care of atomic and temps operations
# attention: watchdog will never return control
watchdog($config) if ($config->{'watchdog'});

################################################################################
# check for data integrity after commiting changes
################################################################################

# call crc check function to ensure integrity
crcCheck($config) if ($config->{'crc-check'});

################################################################################
################################################################################
1;

__DATA__

################################################################################
################################################################################

# from mod_pagespeed src/net/instaweb/http/user_agent_matcher.cc
#
# const char* kImageInliningWhitelist[] = {
#  "*Android*",
#  "*Chrome/*",
#  "*Firefox/*",
#  "*iPad*",
#  "*iPhone*",
#  "*iPod*",
#  "*itouch*",
#  "*MSIE *",
#  "*Opera*",
#  "*Safari*",
#  "*Wget*",
#  // The following user agents are used only for internal testing
#  "google command line rewriter",
#  "webp",
# };
#
# const char* kImageInliningBlacklist[] = {
#  "*Firefox/1.*",
#  "*Firefox/2.*",
#  "*MSIE 5.*",
#  "*MSIE 6.*",
#  "*MSIE 7.*",
#  "*Opera?5*",
#  "*Opera?6*"
# };

__END__


=head1 NAME

webmerge - Asset manager for js/css and related files

=head1 SYNOPSIS

webmerge [options] [steps]

 Options:
   -f, --configfile    main xml configuration
   -d, --doctype       how to render includes [html|xhtml|html5]
   -j, --jobs          number of jobs (commands) to run simultaneously

   -w, --watchdog      start the watchdog process (quit with ctrl+c)

   --webroot           webroot directory to render absolute urls
   --import-css        inline imported css files into stylesheet
   --absoluteurls      export urls as absolute urls (from webroot)

   --referer           optional referer url for external downloads
   --inlinedataexts    file extensions to inline (comma separated)
   --inlinedatamax     maximum file sizes to inline into stylesheets

   --crc-check         run crc check before exiting
   --crc-file          write crc file beside generated files
   --crc-comment       append crc comment into generated files

   --fingerprint       add fingerprints to includes (--fp)
   --fingerprint-dev   for dev context [query|directory|file] (--fp-dev)
   --fingerprint-live  for live context [query|directory|file] (--fp-live)

   --txt-type          text type [nix|mac|win]
   --txt-remove-bom    remove superfluous utf boms
   --txt-normalize-eol normalize line endings to given type
   --txt-trim-trailing trim trailing whitespace in text files

   --headtmpl          text to prepend to generated files
   --jsdeferer         javascript loader for defered loading
   --tmpl-embed-php    embeder template for php embeder generator

   -p, --prepare       enable/disable prepare steps
   -o, --optimize      enable/disable optimize steps
   -m, --merge         enable/disable merge steps
   -i, --headinc       enable/disable headinc steps
   -e, --embeder       enable/disable embeder steps

   --dev               enable/disable dev targets
   --join              enable/disable join targets
   --minify            enable/disable minify targets
   --compile           enable/disable compile targets
   --license           enable/disable license targets

   --optimize-txt      enable/disable optimizer for text files (--txt)
   --optimize-jpg      enable/disable optimizer for jpg images (--jpg)
   --optimize-gif      enable/disable optimizer for gif images (--gif)
   --optimize-png      enable/disable optimizer for png images (--png)
   --optimize-mng      enable/disable optimizer for mng images (--mng)
   --optimize-zip      enable/disable optimizer for zip archives (--zip)
   --optimize-gz       enable/disable optimizer for gz archive files (--gz)

   -dbg, --debug       enable/disable debug mode

   --man               full documentation
   --opts              list command line options
   -?, --help          brief help message with options

 Steps:
   Just process certain steps in configuration

=head1 OPTIONS

=over 8

=item B<-man>

Prints the manual page and exits.

=item B<-opts>

Print a sorted list of command line options and exits.

=item B<-help>

Print a brief help message with options and exits.

=back

=head1 DESCRIPTION

B<This program> merges and optimizes assets for front end web developement.

=cut